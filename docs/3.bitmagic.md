# Практическое применение RISC-V при программировании микроконтроллеров

[(Оглавление)](index.md)

## 3.1. AND (побитовое умножение)

| A | B | A & B |
|---|---|-------|
| 0 | 0 |  0    |
| 0 | 1 |  0    |
| 1 | 0 |  0    |
| 1 | 1 |  1    |

Среди битов результата 1 будет только на тех позициях, на которых **в обоих аргументах были 1**. Если хотя бы в одном аргументе был 0, в результате тоже будет 0.

    A     abcdefgh
    B     00001000  &
    A & B 0000e000
    
**Стирает** все биты аргумента за исключением тех, которые в маске выставлены в 1.

## 3.2. OR (побитовое сложение)

| A | B | A & B |
|---|---|-------|
| 0 | 0 |  0    |
| 0 | 1 |  1    |
| 1 | 0 |  1    |
| 1 | 1 |  1    |

Среди битов результата 0 будет только на тех позициях, на которых **в обоих аргументах был 0**. Если хотя бы в одном аргументе была 1, в результате тоже будет 1.

    A     abcdefgh
    B     00001000  |
    A | B abcd1fgh
    
**Выставляет** в 1 все биты, в которых в маске была 1.

## 3.3. Сдвиги

Аргумент сдвигается на нужное количество битов вправо или влево. Освободившиеся места дополняются нулями.

    A       abcdefgh
    A << 2  cdefgh00
    A >> 2  00abcdef

Простейшая битова маска

    A=1     00000001
    A << 2  00000100
    
Число (битовая маска), содержащее единственный бит на нужной позиции

    A       00000abc
    A << 2  000abc00
    
Число (битовая маска), содержащее последовательность битов начиная с нужной позиции

## 3.4. Побитовая инверсия

Меняет каждый бит на противоположный: 0->1, 1->0

    A       10011110
    ~A      01100001

## 3.5. Запись значения начиная с нужного бита

Например, биты XY начиная с позиции 2. Сначала накладывается маска обнуления нужных битов:

    0b11       00000011
    (0b11<<2)  00001100
    ~(0b11<<2) 11110011

Далее полученная маска накладывается на исходную переменную:

    A          abcdefgh
    ~(0b11<<2) 11110011   &
    B          abcd00gh

Потом формируется значение для присваивания:

    C          000000XY
    (C<<2)     0000XY00

Которое накладывается на обрезанную по маске переменную

    B          abcd00gh
    (C<<2)     0000XY00  |
    D          abcdXYgh

Таким образом путем наложения двух битовых масок можно определенным битам переменной присвоить любое значение.

## 3.6. XOR (Исключающее или)

| A | B | A & B |
|---|---|-------|
| 0 | 0 |  0    |
| 0 | 1 |  1    |
| 1 | 0 |  1    |
| 1 | 1 |  0    |

**Инвертирует** те биты аргумента, в которых **в маске были 1**.

    A     10011110
    B     00100100 ^
    A ^ B 10111010

## 3.7. Специальный регистр BOP

Рассмотренная ранее работа непосредственно с **OCTL** не является безопасной. Если между чтением и записью возникнет прерывание, пытающееся также поменять значение OCTL, после выхода результат его работы будет перезаписан основным кодом. Чтобы этого избежать, в GD32VF103 есть специальный регистр **BOP**, старшие 16 битов которого отвечают за очистку соответствующих битов **OCTL**, а младшие - за выставление в 1:

В данном случае код, реализующий мигалку через чтение **OCTL** и запись **BOP**, приводить не обязательно, поскольку задача абсолютно не ответственная, и можно обойтись xor'ом. К тому же в реальности куда чаще встречается задача сброса в 0 или выставления в 1 независимо от текущего состояния.

### Д/З:

1. Я везде упоминал "побитовое И", "побитовое ИЛИ". Помимо побитового существует еще логическое. Чем они отличаются и в каких случаях что используется?

2. Проверка является ли число степенью двойки.

3. Реальная задача, которую мне когда-то пришлось решать. В заголовочных файлах от производителей часто встречаются битовые маски, покрывающие сразу все поле регистра, например 0b00111000. Биты 3, 4, 5 вместе отвечают за режим работы чего-нибудь. Одна из практических задач - выставить эти биты в нужное значение, например, в 0b001. На языке Си это может выглядеть как

.

    reg = (reg &~(0b111<<3)) | (0b001<<3)

Но здесь мне пришлось указать и размер битового поля, и смещение.
Как при помощи битовой магии добиться того же, зная только маску, покрывающую все поле?
