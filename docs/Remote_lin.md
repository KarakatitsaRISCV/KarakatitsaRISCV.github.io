# Практическое применение RISC-V при программировании микроконтроллеров

[(Оглавление)](index.md)

# Удаленное подключение из Linux + CLI

В качестве способа удаленного подключения к стенду был выбран ssh, соответственно первым делом его надо установить и настроить. В разных дистрибутивах установка делается чуть-чуть по-разному, но проблем не представляет.

Далее при помощи утилиты ```ssh-keygen``` надо сгенерировать пару ключей для доступа (для определенности пусть называются *karakatitsa*), из которых **приватный** (karakatitsa) спрятать куда-нибудь в безопасное место, но чтобы было легко достать. Например, в ```~/.ssh```. А **публичный** (karakatitsa.pub) [каким-либо образом](remote_comm.md) отослать администратору сервера. Приватный ключ надо зарегистрировать: ```aah-add ~/.ssh/karakatitsa```. Теперь к серверу уже можно подключиться при помощи заклинания вида

```
ssh user@012.345.678.90 -p 42 -L100500:localhost:8008
```

Вводить его долго и неприятно, даже несмотря на то, что в нормальном терминале (в отличие от виндового) с историей все в порядке. Поэтому лучше эти данные вписать в настройки ssh. Создаем (или дописываем, если он уже создан) файл ```~/.ssh/config``` и вписываем туда:

```
Host karakatitsa
	Hostname 012.345.678.90
	Port 42
	User user
	LocalForward 100500 localhost:8008
	IdentityFile ~/.ssh/karakatitsa
```

Вместо заглушек, как в данном примере (не бывает ведь IP-адреса 012.345.678.90) вводим те параметры, которые нам дал администратор сервера. Рассмотрим параметры подробнее:

- Host - каково будет имя подключения. Используется только на локальной машине, поэтому можно задать любое

- Hostname, Port - IP-адрес и порт сервера, выдается администратором

- User - логин, также выдается администратором

- LocalForward 100500 localhost:8008 - проброс видеокамеры. Сервер посылает данные на свой 100500-порт (выдается администратором), а ssh благодаря этой настройке перенаправляет на 8008-й порт нашей локальной машины. Соответственно после подключения можно открыть в браузере ```localhost:8008``` и смотреть трансляцию.

- IdentityFile указывает где хранится **приватный** ключ.

Теперь командой ```ssh karakatitsa``` убеждаемся, что подключение есть.

А вот дальнейшие действия будут зависеть от способа, которым вы решите работать. Можно большую часть действий проводить локально, а на сервер отправлять только прошивку, а можно там и исходники хранить, и компиляцию проводить, и прошивать тоже. Рассмотрим оба варианта.

# 1.Локальная сборка на примере Debian

В этом примере вся сборка будет проходить на локальной машине, а на сервер только отправляться файл прошивки. Соответственно надо установить все необходимые пакеты (про настройку своей локальной машины не говорю)

```
apt install gcc-riscv64-unknown-elf make
```

Подключение к серверу у нас уже настроено, поэтому заходим туда и настраиваем скрипт прошивки. Создаем какой-нибдь каталог для личного пользования, например **prog/test**, а в нем файл **prog.sh** со следующим содержимым:

```
#!/bin/bash

stty -F /dev/tty_STFLASH_0 300
stty -F /dev/tty_STFLASH_0 50
echo 'RBU' > /dev/tty_STFLASH_0
echo 'rBU' > /dev/tty_STFLASH_0
sleep 1
stm32flash /dev/tty_STFLASH_0 -w test.bin
stty -F /dev/tty_STFLASH_0 50
echo 'Rbu' > /dev/tty_STFLASH_0
sleep 1
echo 'rbuz' > /dev/tty_STFLASH_0
```

Как видно, это всего лишь кусок makefile, оформленный в виде шелл-скрипта. Соответственно, надо не забыть выдать ему права на исполнение.

Теперь с сервера можно выйти (а можно и не выходить: нам ведь нужна трансляция, да и отладку через UART проводить полезно).

И меняем способ прошивки с локального на удаленный. В makefile меняем цель prog на такую:

```
prog: $(frmname).bin
	scp res/firmware.bin rvstand:/home/user/prog/test/test.bin
	ssh rvstand "cd /home/user/prog/test ; ./prog.sh"
```

В первой строчке происходит копирование собранного бинарника на сервер, а во второй - запуск написанного ранее скрипта, который собственно и прошьет бинарник в контроллер. Вот, собственно, и все. Теперь открываем браузер с трансляцией ```localhost:8008```, запускаем на сервере ```screen``` и делаем с контроллером все, что нужно.

# 2. Удаленная сборка

В простейшем случае никаких особых настроек проводить не надо. Просто подключаемся к серверу, создаем какой-нибудь персональный каталог, например ```prog/remote```, копируем в него какой-нибудь blink, собираем, прошиваем и наслаждаемся результатом. Но не все так просто. В своих примерах я пользовался debian'ом, а там названия пакетов и ключи компиляции несколько отличаются от тех, что используются в ALT Linux на сервере, поэтому придется немного изменить makefile:

```
CROSS_COMPILE=riscv64-linux-gnu-
...
COMMON := -march=rv32imac -mabi=ilp32 -mcmodel=medany -static -gdwarf-2 -fno-plt -fno-pic
ASMFLAGS := $(COMMON)
LDFLAGS := $(COMMON) -Wl,--build-id=none -nostdlib -T lib/gd32vf103cbt6.ld
```

Вот теперь код компилируется и прошивается нормально. Осталось добавить немножко удобства. Как минимум, при отладке постоянно переключаться со screen с логом UART на прошивку неудобно. К счастью, тот же screen позволяет разделить экран при помощи комбинации ```^a + |```. Потом ```^a + Tab``` чтобы переключиться на второе окно и ```^a + c``` чтобы открыть там командную строку. Теперь в одном окне можно открыть screen, а во втором запускать ```make prog```. Переключение между окнами все тем же ```^a + Tab```, выход из каждого ```^a + k, y```.

Также можно открыть браузер по адресу ```localhost:8008``` и смотреть прямую трансляцию контроллера.

Для тех, кто предпочитает командную строку и, например, vim, можно ы том же screen открыть третье окно для редактора кода, и этого достаточно.

Но мне, например, привычнее программировать в kwrite, поэтому воспользуемся функцией монтирования:

```
sshfs karakatitsa:/home/user karakatitsa
```

Теперь каталог karakatitsa отвечает не за нашу локальную машину, а за соответствующий каталог сервера. Переходим в нужный каталог, открываем исходник привычным текстовым редактором и работаем. Только надо не забывать, что компиляцию и прошивку все еще надо делать на сервере.

Ну и по окончании работы не забываем закрыть все подключения.