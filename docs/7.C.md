# Практическое применение RISC-V при программировании микроконтроллеров

[(Оглавление)](index.md)

# 7. Переход на Си

По мере разрастания программы, код на ассемблере становится слишком громоздким, поэтому перед изучением более высокоуровневых концепций стоит разобраться, как программировать на более высокоуровневом языке - на Си. Хорошо "компьютерным" программистам, у них за запуск программы отвечает операционная система, которая может заранее разместить нужные данные по нужным адресам, настроить стек, а о прерываниях можно и не задумываться. Нам же придется все это делать вручную, как обычно путем последовательного изменения предыдущего проекта.

## 7.1 Вызов функции на Си

При программировании на Си, языком описания алгоритма становится именно он, тогда как ассемблер выполняет исключительно служебные задачи - инициализацию секций памяти, настройку аппаратно-зависимых регистров и тому подобного. В соответствии с назначением, главный Си-шный файл будет называться **main.c**, а стартовый ассемблерный - **startup.S**. Как и принято в Си, точкой входа является функция **main()**, в которой будет расположен какой-то "полезный" код. Например, мигалка светодиодом. Доступ к периферии по сравнению с ассемблером ничуть не изменился: пишем нужные чиселки по нужным адресам. В нашем примере это будет выглядеть примерно так:

```C
    #include <stdint.h>
    int main(){
      while(1){
        *((uint32_t*)(0x40010C0C)) ^= (1<<5); //GPIOB_OCTL ^= (1<<RLED);
        for(uint32_t i=0; i<100000; i++)asm volatile("nop"); //цикл задержки, чтобы не слишком быстро мигало
      }
    }
```
    
Эту функцию ассемблерный код и должен вызвать после окончания инициализации. Согласно стандарту, ее прототип выглядит как **int main(int argc, char *argv[])**, то есть функция принимает из окружения два параметра и возвращает один. Вот только окружения у нас нет: код стартует сразу при подаче питания. Ну чтож, значит там будут нули. И возврата в окружение также не предвидится, поэтому вместо **call** обойдемся **j**:

    li a0, 0
    li a1, 0
    j main
    
Осталось правильно настроить заклинание компиляции. Для файлов на Си оно, естественно, будет отличаться от ассемблерных. Приводить его здесь смысла не вижу, проще посмотреть в [makefile](). Ну и разумеется, добавить второй исходник: не только startup (бывший main), но и новый main.

На этом этапе мы получили возможность вызывать "обычный" Си-шный код из ассемблера. Перейдем к "необычному".

## 7.2 Обработчик прерывания

Как мы помним, в RISC-V конвенции для обычных подпрограмм и исключительных ситуаций сильно отличаются. Подпрограммы имеют право не восстанавливать регистры **t0** - **t6**, **a0** - **a7**[^1] и возвращаются по **ret**, тогда как прерывания не имеют права портить **вообще никакие** регистры общего назначения, а возвращаются по **mret**[^2].

[^1]: в видеоматериале я оговорился будто процедура портит сохраняемый регистр. Нет, она портит регистр аргумента, и имеет на это полное право. Точнее, имела бы, будь она процедурой, а не прерыванием

[^2]: кстати, в ARM работа с прерываниями организована по-другому. При входе контроллер **аппаратно** сохраняет все временные регистры на стеке, а при выходе восстанавливает. Таким образом, различия между подпрограммой и обработчиком прерывания на уровне ассемблера там вообще нет

Чтобы дать конять компилятору, что данная функция является именно прерыванием, в gcc используется атрибут *\_\_attribute\_\_((interrupt))*, его и используем для описания обработчика прерывания. Логика его работы не будет отличаться от ассемблерного, ну разве что работа с регистрами снова будет в стиле Си.

## 7.3 Человеко-читаемые имена регистров

Здесь самое время вспомнить, что контроллеры предназначены для решения реальных задач, а не изучения ядра RISC-V. Соответственно, производитель заинтересован в как можно более простом написании кода под свою железку. Увы, некоторые доходят до невменяемости: "вот вам **готовые библиотеки**, а как они устроены внутри, вас не волнует", или даже "вот вам **скриптовый язык**, из которого можете дергать наши подпрограммы". К счастью, библиотека для gd32vf103 к таким не относится. Скачать ее можно прямо на [официальном сайте производителя](gigadevice.com), причем помимо собственно библиотеки, там находятся еще и примеры, и шаблоны проектов для нескольких IDE (я, правда, не слишком разобрался, как их запускать, да и не слишком-то пытался: makefile и консоль проще). Из них нас интересует каталог Firmware, в котором собственно и прописаны регистры. Причем прописаны достаточно интересным способом. Например, GPIOB_OCTL выглядит как

    GPIO_OCTL(GPIOB)
    
Если сравнить с записью от stm32, **GPIOB->OCTL**, видна некоторая избыточность, но зато gd-шная больше соответствует стилю Си (нет натягивания структуры на сырые бинарные данные), да и на макросы она ложится лучше.

Очевидно, что библиотеки от производителя железок в стандартную поставку Си не входят, то есть для использования нам придется прописать все пути и зависимости к ним. Просто смотрим на что ругается компилятор и дописываем соответствующий путь в makefile.

**ВАЖНО** В видеоматериале я прописал макроконстанту -DGD32VF103C_START, это неправильно. Такая запись служит указанием, что мы используем отладочную плату от производителя. То есть этот макрос описывает *всю* обвязку. Для самодельной платы надо укзать только частоту внешнего кварца (хм, а что делать, если его нет?). В нашем случае это флаг **-DHXTAL_VALUE=8000000**




TODO: ссылка на makefile